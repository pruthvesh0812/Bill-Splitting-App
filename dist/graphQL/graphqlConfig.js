"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.graphQLServer = exports.schema = void 0;
// import gql from "graphql-tag";
const server_1 = require("@apollo/server");
const resolvers_1 = __importDefault(require("./resolvers"));
// import { readFileSync } from "fs";
// import path from 'path'
// import { Resolvers } from "./graphql-types";
// import { DataSourceContext } from "./context";
// import { GraphQLResolverMap } from "@apollo/subgraph/dist/schema-helper";
// import { buildSubgraphSchema } from "@apollo/subgraph";
const typeDefs_1 = require("./typeDefs");
// const typeDefs = gql(
//     readFileSync(path.join(__dirname,"./schema.gql"),{encoding:"utf-8"})
// )
const schema_1 = require("@graphql-tools/schema");
const drainHttpServer_1 = require("@apollo/server/plugin/drainHttpServer");
const index_1 = require("../index");
const index_2 = require("../index");
//to convert your Resolvers object to a GraphQLResolverMap<unknown> object.
//resolversMap that maps each type to its corresponding resolvers.
// but doesnt work so not required
// const generateResolverMap = (resolvers:GraphQLResolverMap<DataSourceContext>)=>{
//     if(resolvers){
//         const resolversMap = {
//             Event: {
//                 date: resolvers.Event?.date!,
//                 eventName: resolvers.Event?.eventName!,
//                 id: resolvers.Event?.id!,
//                 paidByUser: resolvers.Event?.paidByUser!,
//                 status: resolvers.Event?.status!,
//                 totalAmount: resolvers.Event?.totalAmount!,
//               },
//               Group: {
//                 admin: resolvers.Group?.admin!,
//                 id: resolvers.Group?.id!,
//                 users: resolvers.Group?.users!,
//               },
//               Mutation: {
//                 createGroup: resolvers.Mutation?.createGroup!,
//                 createUser: resolvers.Mutation?.createUser!,
//                 joinEvent: resolvers.Mutation?.joinEvent!,
//                 onPayment: resolvers.Mutation?.onPayment!,
//                 postEvent: resolvers.Mutation?.postEvent!,
//               },
//               Query: {
//                 getParticipatedEvents: resolvers.Query?.getParticipatedEvents!,
//                 getUserById: resolvers.Query?.getUserById!,
//                 getUsers: resolvers.Query?.getUsers!,
//               },
//               User: {
//                 balance: resolvers.User?.balance!,
//                 email: resolvers.User?.email!,
//                 events: resolvers.User?.events!,
//                 id: resolvers.User?.id!,
//                 password: resolvers.User?.password!,
//                 username: resolvers.User?.username!,
//               },
//           };
//         return resolversMap
//     }
// }
// const resolversMap = generateResolverMap(resolvers)!
/* we need to do this way to get both type safety on
resolvers and type compatibility between resolvers and server resolver mappers
*/
// otherwise we have to compromise on either one - basically the type safety
/*
 dont use buildSubgraphSchema inside ApolloServer - you wont to be able to
 use type safety - due to the type compatibility between resolver
 types generated by codegen and the GraphQLResolverMap
*/
// this works well 
exports.schema = (0, schema_1.makeExecutableSchema)({ typeDefs: typeDefs_1.typeDefs, resolvers: resolvers_1.default });
exports.graphQLServer = new server_1.ApolloServer({
    schema: exports.schema,
    plugins: [
        // Proper shutdown for the HTTP server.
        (0, drainHttpServer_1.ApolloServerPluginDrainHttpServer)({ httpServer: index_2.httpServer }),
        // Proper shutdown for the WebSocket server.
        {
            serverWillStart() {
                return __awaiter(this, void 0, void 0, function* () {
                    return {
                        drainServer() {
                            return __awaiter(this, void 0, void 0, function* () {
                                yield index_1.serverCleanup.dispose();
                            });
                        },
                    };
                });
            },
        },
    ],
});
